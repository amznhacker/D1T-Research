# D1T-Research

Unitree D1-T Research - [Official Documentation](https://support.unitree.com/home/en/developer/D1Arm_services)

**Last Updated:** 2025-12-02 12:12:43

## D1 Mechanical Arm Services Interface

### Introduction

The service starts when the steering gear arm of D1 is powered on, and the control function of the manipulator arm is realized by invoking the interface of the service. The specific functions are as follows:

| Function | Description |
|----------|-------------|
| Single joint angle control | By controlling the motor angle of a single joint of the robot arm |
| All joint angle control | By controlling the motor angle of all joints of the robot arm |
| Single arm joint motor enable/discharge force control | Control joint motor state as locked/free. In the free state, with the joint angle feedback interface, drag memory teaching |
| All joint motors enable/unload force control | Control the state of all joint motors as lock/free. With the joint angle feedback interface in free state, drag memory teaching |
| Power supply switch of the motor | Controls whether to power the motor (can be used for emergency stop) |
| Robotic arm position return to zero | Return to zero from any position |
| Robot arm joint angle feedback | Feedback real-time angle of robot arm joint |
| Robot arm status feedback | Feedback the enable/discharge status and power-on status of the robot arm |
| Command receive feedback | The feedback after receiving the control command is regarded as successful reception |
| Command execution feedback | Feedback after the control command is executed, which indicates that the command is successfully executed |

## Specification Parameters

### Structural Parameters

| Parameter | Value |
|-----------|-------|
| Model | D1-550 |
| Weight | 3152g |
| Degrees of Freedom | 6 (degrees of freedom) + 1 (gripper) |
| Arm length | 550mm (excluding jaws), 670mm (including jaws) |
| Rated load | 500g (including clamp weight) |
| Working radius | 550mm |
| Motor type | Bus servo |

#### Torque of Each Joint Motor

- J0: 3.3NM
- J1: 3.3NM
- J2: 1.7NM
- J3: 1.7NM
- J4: 1.7NM
- J5: 1.7NM
- J6: 1.7NM

#### Range of Motion for Each Joint

- J0: ±135°
- J1: ±90°
- J2: ±90°
- J3: ±135°
- J4: ±90°
- J5: ±135°
- Claw stroke: 0-65mm

### Electrical Parameters

| Parameter | Value |
|-----------|-------|
| Power requirement | 24V 10A (15-48V) |
| Power | 240W |
| Controller | Integrated (4 x Cortex-A55 1.8GHz) |
| Communication method | RJ45 (Ethernet 100Mbps communication) + Type-C (serial port debugging) |
| Control Method | DDS Subscription |
| Control cycle | 10Hz |

### Mechanical Arm Structure Diagram

The robot arm has 6 basic axes + 1 clamp, starting from the base (0) to the clamp (6).

## Interface Protocol

All data is transmitted using strings in JSON format, including:
- `seq` (unique identifier)
- `address` (instruction address code)
- `funcode` (instruction function code)
- `data` (data content, which can be nested with JSON data)

The `seq` of the command to be sent is automatically generated by the calling end, except that the `seq` of the active message is 10 (hardcoded). In order to distinguish the sequence of reply messages, no parsing is required, and only the `seq` of this command is sent back when the reply is made.

### Command Reference Table

| Function | seq | address | funcode | data | Example | Description |
|----------|-----|---------|---------|------|---------|-------------|
| Angle control of single robotic arm joint | Caller generates | 1 | 1 | id, angle, delay_ms | `{"seq":4,"address":1,"funcode":1,"data":{"id":5,"angle":60,"delay_ms":0}}` | `id` is the joint number, `angle` is the target angle, `delay_ms` execution time (temporarily set to 0) |
| All robotic arm joint angle control | Caller generates | 1 | 2 | mode and angle0~6 | `{"seq":4,"address":1,"funcode":2,"data":{"mode":1,"angle0":0,"angle1":-60,"angle2":60,"angle3":0,"angle4":30,"angle5":0,"angle6":0}}` | `mode` is control mode (0 = small smoothing at 10Hz, 1 = large smoothing for trajectory), `angle0~6` are joint angle values |
| Enable/force discharge control of single joint motor | Caller generates | 1 | 4 | id, mode | `{"seq":4,"address":1,"funcode":4,"data":{"id":5,"mode":1}}` | `id` is joint ID, `mode` 0 = release force, 1 = enable |
| Enable/force discharge control of all joint motors | Caller generates | 1 | 5 | mode | `{"seq":4,"address":1,"funcode":5,"data":{"mode":0}}` | `mode` 0 = unload, 1 = enable |
| Power supply switch of mechanical arm motor | Caller generates | 1 | 6 | power | `{"seq":4,"address":1,"funcode":6,"data":{"power":1}}` | `power` 0 = powered off, 1 = powered on |
| Robotic arm posture returns to zero | Caller generates | 1 | 7 | none | `{"seq":4,"address":1,"funcode":7}` | None |
| Mechanical joint angle feedback | 10 | 2 | 1 | angle0~6 | `{"seq":10,"address":2,"funcode":1,"data":{"angle0":0,"angle1":-60,"angle2":60,"angle3":0,"angle4":30,"angle5":0,"angle6":0}}` | Feedback real-time angle of joints, upload frequency 10Hz |
| Robotic arm status feedback | 10 | 2 | 3 | enable_status, power_status, error_status | `{"seq":10,"address":2,"funcode":3,"data":{"enable_status":1,"power_status":1,"error_status":1}}` | `enable_status`: 1 = enabled, 0 = disabled. `power_status`: 1 = powered, 0 = not powered. `error_status`: 1 = normal, 0 = abnormal |
| Online status detection of mechanical arm motor | 10 | 2 | 4 | motor0_status~motor6_status | `{"seq":10,"address":2,"funcode":4,"data":{"motor0_status":1,"motor1_status":1,"motor2_status":1,"motor3_status":1,"motor4_status":1,"motor5_status":1,"motor6_status":1}}` | Motor status: 0 = faulty, 1 = normal |
| Command receive feedback | Caller generates | 3 | 1 | recv_status | `{"seq":10,"address":3,"funcode":1,"data":{"recv_status":1}}` | `recv_status`: 1 = successful, 0 = failed (format incorrect, cannot parse, out of function scope, etc.) |
| Command execution feedback | Caller generates | 3 | 2 | exec_status | `{"seq":10,"address":3,"funcode":2,"data":{"exec_status":1}}` | `exec_status`: 1 = execution succeeds, 0 = execution fails |

### DDS Topics

The service provides two interfaces:
- **`rt/arm_Command`**: Sends data and command requests to the service
- **`rt/arm_Feedback`**: Gets data uploaded by the service

### Message Type Definition

The `ArmString_` message type is defined as follows:

```cpp
// generated from rosidl_generator_dds_idl/resource/idl.idl.em
// with input from unitree_arm:msg/ArmString.idl
// generated code does not contain a copyright notice

#ifndef __unitree_arm__msg__arm_string__idl__
#define __unitree_arm__msg__arm_string__idl__

module unitree_arm {
    module msg {
        module dds_ {
            struct ArmString_ {
                string data_;
            };
        };  // module dds_
    };  // module msg
};  // module unitree_arm

#endif  // __unitree_arm__msg__arm_string__idl__
```

## SDK and Sample Programs

### Acquisition and Use

The SDK and sample program running environment of the robot arm rely on `unitree_sdk2`, and it is necessary to deploy `unitree_sdk2` before the development of D1.

**Download SDK:** [d1_sdk.zip](https://unitree-firmware.oss-cn-hangzhou.aliyuncs.com/tool/d1_sdk.zip)

After the download is complete, create a folder in it, and use `cmake` to build and `make` to compile.

### Sample Programs

- **`arm_zero_control.cpp`**: Robot arm zero example program
- **`get_arm_joint_angle.cpp`**: Obtain the robotic arm joint angle value sample program
- **`joint_angle_control.cpp`**: Robot arm single joint angle control example program
- **`joint_enable_control.cpp`**: Robot arm joint enable control example program
- **`multiple_joint_angle_control.cpp`**: Robot arm multi-joint angle control example program

### SDK Integration

The `msg` file is the D1 robot arm SDK interface file that we need to use. In the future, we only need to add these files in our own project. You can also copy the file to `/usr/local/include`, add it to the directory `include_directories`, and use `link_libraries` to link files.

**Note:** Currently only Ubuntu is supported. Depends on `unitree_sdk2`.

## Robotic Arm Models

### Download Links

- **Gripper version:** [Download](https://oss-global-cdn.unitree.com/static/90b2525be5d84531ab9814f48b2f86a7.zip)
- **Grip-free version:** [Download](https://oss-global-cdn.unitree.com/static/02c95ece8e354143b874a3c963241467.zip)

### Model Files

- **STEP:** STEP Simplified Model
- **D1-550 STEP:** D1-550 STEP
- **D1-550 URDF:** D1-550 URDF
- **D1-550 gripper open source files:** D1-550 gripper open source files

### Version Differences

| Category | Differences |
|----------|-------------|
| Gripper version | The end gripper can be opened and closed through the slider interface, which is suitable for the development of grasping tasks under simulation |
| Gripless version | The end gripper has a fixed structure and is fixed to the end shaft of the manipulator. The gripper cannot be opened or closed. It is suitable for only cloud end pose simulation task |

## IAP Upgrade

After connecting the robot arm to the computer, enter the IP address `:8080` in the browser to enter the IAP upgrade interface. Drag the upgrade package provided by us and click Upload to realize the upgrade of the robot arm system.

**Default IP address:** `192.168.123.100`

## Usage Examples

### 1. Single Joint Angle Control of Mechanical Arm

Using the `rt/arm_Command` topic, assume that the generated `seq` value is 4 and set the angle of joint 5 to 60°.

**Data content:** `{"seq":4,"address":1,"funcode":1,"data":{"id":5,"angle":60,"delay_ms":0}}`

```cpp
#include <unitree/robot/channel/channel_publisher.hpp>
#include <unitree/common/time/time_tool.hpp>
#include "msg/ArmString_.hpp"

#define TOPIC "rt/arm_Command"

using namespace unitree::robot;
using namespace unitree::common;

int main()
{
    ChannelFactory::Instance()->Init(0);
    ChannelPublisher<unitree_arm::msg::dds_::ArmString_> publisher(TOPIC);
    publisher.InitChannel();

    unitree_arm::msg::dds_::ArmString_ msg{};
    msg.data_() = "{\"seq\":4,\"address\":1,\"funcode\":1,\"data\":{\"id\":5,\"angle\":60,\"delay_ms\":0}}";
    publisher.Write(msg);
 
    return 0;
}
```

### 2. Multi-Joint Angle Control of Mechanical Arm

Using the `rt/arm_Command` topic, assume that the generated `seq` value is 4 and the joint angles of the manipulator arm are {0, -60, 60, 0, 30, 0, 0}.

**Data content:** `{"seq":4,"address":1,"funcode":2,"data":{"mode":1,"angle0":0,"angle1":-60,"angle2":60,"angle3":0,"angle4":30,"angle5":0,"angle6":0}}`

```cpp
#include <unitree/robot/channel/channel_publisher.hpp>
#include <unitree/common/time/time_tool.hpp>
#include "msg/ArmString_.hpp"

#define TOPIC "rt/arm_Command"

using namespace unitree::robot;
using namespace unitree::common;

int main()
{
    ChannelFactory::Instance()->Init(0);
    ChannelPublisher<unitree_arm::msg::dds_::ArmString_> publisher(TOPIC);
    publisher.InitChannel();

    unitree_arm::msg::dds_::ArmString_ msg{};
    msg.data_() = "{\"seq\":4,\"address\":1,\"funcode\":2,\"data\":{\"mode\":1,\"angle0\":0,\"angle1\":-60,\"angle2\":60,\"angle3\":0,\"angle4\":30,\"angle5\":0,\"angle6\":0}}";
    publisher.Write(msg);
 
    return 0;
}
```

### 3. Enable/Unload Force Control of Mechanical Arm Joint Motor

Through the `rt/arm_Command` topic, assuming that the `seq` value generated at this time is 4, control all joints to unload force.

**Data content:** `{"seq":4,"address":1,"funcode":5,"data":{"mode":0}}`

```cpp
#include <unitree/robot/channel/channel_publisher.hpp>
#include <unitree/common/time/time_tool.hpp>
#include "msg/ArmString_.hpp"

#define TOPIC "rt/arm_Command"

using namespace unitree::robot;
using namespace unitree::common;

int main()
{
    ChannelFactory::Instance()->Init(0);
    ChannelPublisher<unitree_arm::msg::dds_::ArmString_> publisher(TOPIC);
    publisher.InitChannel();

    unitree_arm::msg::dds_::ArmString_ msg{};
    msg.data_() = "{\"seq\":4,\"address\":1,\"funcode\":5,\"data\":{\"mode\":0}}";
    publisher.Write(msg);
 
    return 0;
}
```

**Note:** The `mode` ranges from 0 to 80000. 0 is fully unloaded and 80000 is fully locked.

### 4. Robotic Arm Position and Posture Return to Zero

Through the `rt/arm_Command` topic, assuming that the `seq` value generated at this time is 4, the manipulator is controlled to return to zero position.

**Data content:** `{"seq":4,"address":1,"funcode":7}`

```cpp
#include <unitree/robot/channel/channel_publisher.hpp>
#include <unitree/common/time/time_tool.hpp>
#include "msg/ArmString_.hpp"

#define TOPIC "rt/arm_Command"

using namespace unitree::robot;
using namespace unitree::common;

int main()
{
    ChannelFactory::Instance()->Init(0);
    ChannelPublisher<unitree_arm::msg::dds_::ArmString_> publisher(TOPIC);
    publisher.InitChannel();

    unitree_arm::msg::dds_::ArmString_ msg{};
    msg.data_() = "{\"seq\":4,\"address\":1,\"funcode\":7}";
    publisher.Write(msg);
 
    return 0;
}
```

### 5. Obtain Real-Time Joint Angle

The `seq` value of the instruction is fixed at 10, the upload frequency is 10Hz, and the data is distinguished by the `address` + `funcode`, which requires callback monitoring.

```cpp
#include <unitree/robot/channel/channel_subscriber.hpp>
#include <unitree/common/time/time_tool.hpp>
#include "msg/PubServoInfo_.hpp"
#include "msg/ArmString_.hpp"

#define TOPIC "current_servo_angle"
#define TOPIC1 "arm_Feedback"

using namespace unitree::robot;
using namespace unitree::common;

void Handler(const void* msg)
{
    const unitree_arm::msg::dds_::PubServoInfo_* pm = (const unitree_arm::msg::dds_::PubServoInfo_*)msg;

    std::cout << "servo0_data:" << pm->servo0_data_() 
              << ", servo1_data:" << pm->servo1_data_() 
              << ", servo2_data:" << pm->servo2_data_() 
              << ", servo3_data:" << pm->servo3_data_() 
              << ", servo4_data:" << pm->servo4_data_() 
              << ", servo5_data:" << pm->servo5_data_() 
              << ", servo6_data:" << pm->servo6_data_() 
              << std::endl;
}

void Handler1(const void* msg)
{
    const unitree_arm::msg::dds_::ArmString_* pm = (const unitree_arm::msg::dds_::ArmString_*)msg;

    std::cout << "armFeedback_data:" << pm->data_() << std::endl;
}

int main()
{
    ChannelFactory::Instance()->Init(0);
    ChannelSubscriber<unitree_arm::msg::dds_::PubServoInfo_> subscriber(TOPIC);
    subscriber.InitChannel(Handler);

    ChannelSubscriber<unitree_arm::msg::dds_::ArmString_> subscriber1(TOPIC1);
    subscriber1.InitChannel(Handler1);

    while (true)
    {
        sleep(10);
    }

    return 0;
}
```

## D1-T Configuration and Usage

### Basic Demo

D1-T uses routers/switches to achieve data communication between two D1 robotic arms. The joint data of one robotic arm is input to the other robotic arm for execution. The default IP address of the D1 robot arm is `192.168.123.100`. When using D1-T, we need to change the IP address of the other robot arm to `192.168.123.xxx` (e.g., `192.168.123.99`). We can also modify it according to our own needs.

The D1-T consists of two sets of D1 robotic arms, one of which has a hand-held claw at the end, which acts as the data acquisition end. Power on any robot arm and connect it to the router/switch through a network cable.

### Router Configuration

We need to go to the background management interface of the router, change the WAN network segment to `192.168.123.xx` in the location of the router IP address assignment.

After the modification is successful and saved, use your PC to connect to the router and run:

```bash
ping 192.168.123.100
```

Check whether the communication is normal.

### Change the IP Address of the Manipulator

After ensuring that the communication between the computer and the robot arm is correct, open the terminal and log in to the robot arm system through SSH (password: `123`):

```bash
ssh ubuntu@192.168.123.100
```

After the login is successful, enter the IP configuration path `/etc/network`, and change the IP address in the interface file to `192.168.123.99` through the `vim` command. After the modification, save the IP address and restart the system.

Power on the other robotic arm and connect it to the router. The IP addresses of the two robotic arms are `192.168.123.99` and `192.168.123.100` respectively. Run the `ping` command to check the two IP addresses to ensure normal communication.

## Multi-Robot Arm Control

When using two or more robotic arms, there are two possible scenarios:

1. Multiple robotic arms connected to the same computer
2. The computer and robotic arms connected to the same router

To control these two or more robotic arms individually, there are two methods:

### Method 1: Multiple Robotic Arms Connected to the Same Computer

When multiple robotic arms are connected to the same computer, multiple network adapters (NICs) will appear on the computer. You only need to bind each robotic arm to the corresponding NIC.

First, we need to know which NIC the robotic arm to be controlled is bound to. You can get the NIC information using the following command:

```bash
ip addr show
```

In this example, the robotic arm is bound to the `eth0` NIC.

Open the official sample program "Arm Pose Zeroing", and in the first line of the main function you can see the initialization code for the robotic arm:

```cpp
int main()
{
    ChannelFactory::Instance()->Init(0);
    ChannelPublisher<unitree_arm::msg::dds_::ArmString_> publisher(TOPIC);
    publisher.InitChannel();

    unitree_arm::msg::dds_::ArmString_ msg{};
    msg.data_() = "{\"seq\":4,\"address\":1,\"funcode\":7}";
    publisher.Write(msg);
 
    return 0;
}
```

In the initialization, simply add the NIC name you want to bind to in order to control the robotic arm connected to that NIC:

```cpp
ChannelFactory::Instance()->Init(0, "eth0");
```

### Method 2: Computer and Robotic Arms Connected to the Same Router

When the computer and robotic arms are connected to the same router, the computer has only one NIC connected to all the robotic arms. In this case, you need to modify the internal driver files of the robotic arms.

First, you need to know that all control commands of the robotic arm are transmitted via DDS. By subscribing to the required topic in the program, you can get the desired messages.

Since all robotic arms use the same topic for control commands, to control different robotic arms within the same LAN, you just need to make each robotic arm's control topic unique. Start by connecting only one robotic arm.

#### Modifying the Robotic Arm Driver Code

When modifying the robotic arm driver code, first stop the default running services:

```bash
sudo systemctl stop marm_controller.service
sudo systemctl stop marm_control.service
sudo systemctl stop marm_communication.service
sudo systemctl stop marm_subscripber.service

sudo systemctl disable marm_controller.service
sudo systemctl disable marm_control.service
sudo systemctl disable marm_communication.service
sudo systemctl disable marm_subscripber.service
```

After connecting to the robotic arm via SSH, enter the following command:

```bash
vim marm_code/src/marm_communication_node.cpp
```

You will see the internal driver code:

```cpp
#include <unitree/robot/channel/channel_publisher.hpp>
#include <unitree/robot/channel/channel_subscriber.hpp>
#include <unitree/common/time/time_tool.hpp>

#include "msg/ArmString_.hpp"
#include "msg/PubServoInfo_.hpp"
#include "msg/SetServoAngle_.hpp"
#include "msg/SetServoDumping_.hpp"

#include <rapidjson/document.h>
#include <rapidjson/stringbuffer.h>
#include <rapidjson/writer.h>

#include <iostream>
#include <thread>
#include <chrono>

#define SubArmCommand_Topic "rt/arm_Command"
#define SubServoCurrentAngle_Topic "current_servo_angle"
#define PubArmFeedback_Topic "rt/arm_Feedback"
#define PubArmZero_Topic "arm_zero"
#define PubServoAngle_Topic "set_servo_angle"
#define PubServoAngleControl_Topic "set_servo_angle_control"
#define PubServoDumping_Topic "set_servo_dumping"
```

Find the topic that matches the control command in the "Arm Pose Zeroing" sample program:

```cpp
#define SubArmCommand_Topic "rt/arm_Command"
```

Change it to a unique topic, for example:

```cpp
#define SubArmCommand_Topic "rt/arm_Command_1"
```

After finishing, save and exit, wait for recompilation to complete, then restart the services and the robotic arm:

```bash
cd ~
cd marm_code/build/
make clean
make

sudo systemctl enable marm_communication.service 
sudo systemctl enable marm_control.service 
sudo systemctl enable marm_controller.service 
sudo systemctl enable marm_subscripber.service 

sudo reboot

sudo systemctl start marm_communication.service 
sudo systemctl start marm_control.service 
sudo systemctl start marm_controller.service 
sudo systemctl start marm_subscripber.service
```

Once this operation succeeds, append a special suffix to all topics in the `marm_code/src` driver files inside the robotic arm, so that each arm has unique topics within the LAN. For example:

**`/marm_code/src/marm_communication_node.cpp`**

```cpp
#define SubArmCommand_Topic "rt/arm_Command_1"
#define SubServoCurrentAngle_Topic "current_servo_angle_1"
#define PubArmFeedback_Topic "rt/arm_Feedback_1"
#define PubArmZero_Topic "arm_zero_1"
#define PubServoAngle_Topic "set_servo_angle_1"
#define PubServoAngleControl_Topic "set_servo_angle_control_1"
#define PubServoDumping_Topic "set_servo_dumping_1"
```

**`/marm_code/src/marm_control_node.cpp`**

```cpp
#define PubServoAngle_Topic "set_servo_angle_1"
#define PubArmFeedback_Topic "rt/arm_Feedback_1"
#define SubArmZero_Topic "arm_zero_1"
#define SubServoAngleControl_Topic "set_servo_angle_control_1"
#define SubServoCurrentAngle_Topic "current_servo_angle_1"
```

**`/marm_code/src/marm_controller_node.cpp`**

```cpp
#define PubArmFeedback_Topic "rt/arm_Feedback_1"
#define PubServoAngle_Topic "current_servo_angle_1"
#define SubServoAngle_Topic "set_servo_angle_1"
#define SubServoDumping_Topic "set_servo_dumping_1"
```

#### Possible Compilation Issues and Solutions

**Compilation failure:** Delete the entire build folder and recompile.

**Errors caused by incorrect file time**, such as:
```
make: Warning: File 'Makefile' has modification time xxx s in the future
Warning: File 'xxx' has modification time yyy s in the future
warning: Clock skew detected. Your build may be incomplete.
```

Fix by setting the system clock to the current time, for example:

```bash
sudo date -s yyyy-mm-dd
```

At this point, change the control command topic in the "Arm Pose Zeroing" sample program to match the unique topic. This way, you can control the specific robotic arm. The same principle applies if you want to get the angle data of a specific robotic arm. For example:

```cpp
#include <unitree/robot/channel/channel_publisher.hpp>
#include <unitree/common/time/time_tool.hpp>
#include "msg/ArmString_.hpp"

#define TOPIC "rt/arm_Command_1"

using namespace unitree::robot;
using namespace unitree::common;

int main()
{
    ChannelFactory::Instance()->Init(0);
    ChannelPublisher<unitree_arm::msg::dds_::ArmString_> publisher(TOPIC);
    publisher.InitChannel();

    unitree_arm::msg::dds_::ArmString_ msg{};
    msg.data_() = "{\"seq\":4,\"address\":1,\"funcode\":7}";
    publisher.Write(msg);
 
    return 0;
}
```

This completes the process of controlling a specific robotic arm.

## Starting the Robotic Arm Program

A robot arm without a hand-held device is called an **execution robot arm**, and a robot arm with a hand-held device is called an **acquisition robot arm**.

To execute the robot arm, use the default program. To collect the robot arm, we need to stop the default program, use our acquisition interface program, and use the following command to stop the currently running service:

```bash
sudo systemctl stop marm_controller.service
sudo systemctl stop marm_control.service
sudo systemctl stop marm_communication.service
sudo systemctl stop marm_subscripber.service
```

This command will stop the factory program in the current system. If you need to stop permanently, continue to execute the following command:

```bash
sudo systemctl disable marm_controller.service
sudo systemctl disable marm_control.service
sudo systemctl disable marm_communication.service
sudo systemctl disable marm_subscripber.service
```

You can view the current status of the service by:

```bash
sudo systemctl status <service_name>
```
